var documenterSearchIndex = {"docs":
[{"location":"#PolyFlows","page":"Home","title":"PolyFlows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PolyFlows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Exported-functions","page":"Home","title":"Exported functions","text":"","category":"section"},{"location":"#PolyFlows.EulerSampleIntegrator-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Vararg{Int64, N}}} where {T, N}","page":"Home","title":"PolyFlows.EulerSampleIntegrator","text":"EulerSampleIntegrator(ScalarType, dims...)\n\nIntegrator for Euler scheme that uses state of dimension (dims...). Space complexity: prod(dims...)\n\n\n\n\n\n","category":"method"},{"location":"#PolyFlows.LinearInterpolant","page":"Home","title":"PolyFlows.LinearInterpolant","text":"LinearInterpolant(α, β, α̇, β̇, [tol], [η, α̇/α])\n\nForms the linear interpolant X_t = alpha(t) X_1 + beta(t) X_0. See [1] for definition of eta.\n\n\n\n\n\n","category":"type"},{"location":"#PolyFlows.RK4SampleIntegrator-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Vararg{Int64, N}}} where {T, N}","page":"Home","title":"PolyFlows.RK4SampleIntegrator","text":"RK4SampleIntegrator(ScalarType, dims...)\n\nIntegrator for Runge-Kutta 4 scheme that uses state of dimension (dims...). Space complexity: 3prod(dims...)\n\n\n\n\n\n","category":"method"},{"location":"#PolyFlows.McCannInterpolant-Tuple{}","page":"Home","title":"PolyFlows.McCannInterpolant","text":"See LinearInterpolant. α = t, β = 1-t\n\n\n\n\n\n","category":"method"},{"location":"#PolyFlows.SqrtInterpolant","page":"Home","title":"PolyFlows.SqrtInterpolant","text":"See LinearInterpolant. α = √t, β = 1-√t\n\n\n\n\n\n","category":"function"},{"location":"#PolyFlows.SquareInterpolant","page":"Home","title":"PolyFlows.SquareInterpolant","text":"See LinearInterpolant. α = t², β = 1-t²\n\n\n\n\n\n","category":"function"},{"location":"#PolyFlows.TrigInterpolant","page":"Home","title":"PolyFlows.TrigInterpolant","text":"See LinearInterpolant. α = sin(πt/2), β = cos(πt/2)\n\n\n\n\n\n","category":"function"},{"location":"#PolyFlows.create_LS_stoch_interp-Union{Tuple{x_t_dim}, Tuple{AbstractMatrix, MultivariateExpansions.MultivariateBasis{x_t_dim}, MultiIndexing.FixedMultiIndexSet{x_t_dim}, PolyFlows.AbstractStochInterpolant, AbstractVector}, Tuple{AbstractMatrix, MultivariateExpansions.MultivariateBasis{x_t_dim}, MultiIndexing.FixedMultiIndexSet{x_t_dim}, PolyFlows.AbstractStochInterpolant, AbstractVector, AbstractVector}} where x_t_dim","page":"Home","title":"PolyFlows.create_LS_stoch_interp","text":"create_LS_stoch_interp(data::AbstractMatrix, basis::MultivariateBasis, fmset::FixedMultiIndexSet, \ninterp::AbstractStochInterpolant, time_pts, time_wts; [rng])\n\nCreate a least-squares system for the stochastic interpolant.\n\nIf N=length(fmset), then this returns a NxN matrix and a Nxd vector, where d is the dimension of the state (keeping in mind that fmset is d+1 dimensional)\n\nArguments\n\ndata (M,d) samples drawn from target\nbasis (d+1) basis for the space variables concatenated with time basis\nfmset (N,d+1) set of multi-indices\ninterp stochastic interpolant\ntime_pts (T) set of points to integrate loss over in time\ntime_wts (T) set of weights for time integration rule. Defaults to uniform.\n[rng] (optional) RNG from Random\n\n\n\n\n\n","category":"method"},{"location":"#Private-functions","page":"Home","title":"Private functions","text":"","category":"section"},{"location":"#PolyFlows.initialize_interpolant_spaces-Union{Tuple{dim_x_t}, Tuple{T}, Tuple{AbstractMatrix{T}, MultiIndexing.FixedMultiIndexSet{dim_x_t}, Random.AbstractRNG}} where {T, dim_x_t}","page":"Home","title":"PolyFlows.initialize_interpolant_spaces","text":"initialize_interpolant_spaces(data::AbstractMatrix{T}, fmset::FixedMultiIndexSet{dim_x_t}, rng)\n\nCreate spaces for storing intermediate results for learning the stochastic interpolant.\n\n\n\n\n\n","category":"method"},{"location":"#PolyFlows.state_and_velocity!-Union{Tuple{M}, Tuple{T}, Tuple{M, M, M, M, LinearInterpolant, T}} where {T, M<:AbstractMatrix{T}}","page":"Home","title":"PolyFlows.state_and_velocity!","text":"state_and_velocity!(state, velocity, data, noise, interp, time)\n\nGet X_t = alpha(t) X_1 + beta(t) X_0 as well as dotX_t, where X_1 is drawn from the target and X_0 from the reference.\n\nOutput results into state and velocity.\n\nArguments\n\nstate: Matrix (M, d+1) for (X_t t), i.e., augmenting the state with the time\nvelocity: Matrix (M, d) for dotX_t\ndata: Matrix (M, d) for X_1\nnoise: Matrix (M, d) for X_0\ninterp::LinearInterpolation\ntime::Number\n\n\n\n\n\n","category":"method"},{"location":"#PolyFlows.velocity_basis_eval_step!-Union{Tuple{M}, Tuple{T}, Tuple{x_t_dim}, Tuple{M, NTuple{x_t_dim, M}, MultivariateExpansions.MultivariateBasis{x_t_dim}, MultiIndexing.FixedMultiIndexSet{x_t_dim}, M}} where {x_t_dim, T<:Number, M<:AbstractMatrix{T}}","page":"Home","title":"PolyFlows.velocity_basis_eval_step!","text":"velocity_basis_eval_step!(full_eval_space, univariate_eval_space, basis, fmset, state)\n\nEvaluate Phi(X_t^(j)t)_j=1^Msubset mathbbR^N for fixed t. Note that state should be (X_t^(j)t), i.e., augmented with the time pt, so dimension is d+1\n\nArguments\n\nfull_eval_space: Matrix (N,M)\nunivariate_eval_space::NTuple{d+1}: Each matrix is (p_j,M), where p_j is the maximum degree of basis function in dim j\nbasis::MultivariateBasis{d+1}\nfmset::FixedMultiIndex{d+1}\nstate Matrix (M,d+1)\n\n\n\n\n\n","category":"method"}]
}
